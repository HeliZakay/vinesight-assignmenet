[{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/next.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/scripts/smoke.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/app/api/posts/[id]/status/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[990,993],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[990,993],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from \"next/server\";\nimport { getPosts } from \"@/lib/posts\";\nimport { PostStatus } from \"@/lib/statuses\";\n\n/**\n * PATCH /api/posts/[id]/status\n * Updates the status of a post identified by ID.\n */\nexport async function PATCH(\n  request: Request,\n  context: { params: Promise<{ id: string }> }\n) {\n  // Extract post ID from route params\n  const { id } = await context.params;\n\n  // Ensure the request has JSON content\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (!contentType.toLowerCase().includes(\"application/json\")) {\n    return NextResponse.json(\n      { error: \"Unsupported Media Type. Expected application/json\" },\n      { status: 415 }\n    );\n  }\n\n  // Parse the request body safely\n  let body: unknown;\n  try {\n    body = await request.json();\n  } catch {\n    return NextResponse.json(\n      { error: \"Invalid JSON in request body\" },\n      { status: 400 }\n    );\n  }\n\n  // Extract `status` field from body\n  const status = (body as any)?.status;\n  if (typeof status !== \"string\") {\n    return NextResponse.json(\n      { error: \"Field 'status' is required and must be a string\" },\n      { status: 400 }\n    );\n  }\n\n  // Normalize and validate status value\n  const normalized = status.toLowerCase();\n  const allowed = new Set<string>(Object.values(PostStatus));\n  if (!allowed.has(normalized)) {\n    return NextResponse.json(\n      {\n        error: `Invalid status '${status}'. Allowed: ${[...allowed].join(\n          \", \"\n        )}`,\n      },\n      { status: 400 }\n    );\n  }\n\n  // Find the post by ID\n  const posts = getPosts();\n  const post = posts.find((p) => p.id === id);\n\n  // Return 404 if post not found\n  if (!post) {\n    return NextResponse.json({ error: \"Post not found\" }, { status: 404 });\n  }\n\n  // Update status and return updated post\n  post.status = normalized as PostStatus;\n  return NextResponse.json(post);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/app/api/posts/[id]/tags/[tag]/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/app/api/posts/[id]/tags/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[916,919],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[916,919],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from \"next/server\";\nimport { getPosts } from \"@/lib/posts\";\n\n/**\n * POST /api/posts/[id]/tags\n * Adds a new tag to the specified post.\n\n */\nexport async function POST(\n  request: Request,\n  context: { params: Promise<{ id: string }> }\n) {\n  // Extract post ID from route params\n  const { id } = await context.params;\n\n  // Ensure the request has JSON content\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (!contentType.toLowerCase().includes(\"application/json\")) {\n    return NextResponse.json(\n      { error: \"Unsupported Media Type. Expected application/json\" },\n      { status: 415 }\n    );\n  }\n\n  // Parse the request body safely\n  let body: unknown;\n  try {\n    body = await request.json();\n  } catch {\n    return NextResponse.json(\n      { error: \"Invalid JSON in request body\" },\n      { status: 400 }\n    );\n  }\n\n  // Validate `tag` field\n  let tag = (body as any)?.tag;\n  if (typeof tag !== \"string\") {\n    return NextResponse.json(\n      { error: \"Field 'tag' is required and must be a string\" },\n      { status: 400 }\n    );\n  }\n\n  // Normalize tag value (trim + lowercase)\n  tag = tag.trim().toLowerCase();\n  if (tag.length === 0 || tag.length > 30) {\n    return NextResponse.json(\n      { error: \"Tag must be 1-30 characters after trimming\" },\n      { status: 400 }\n    );\n  }\n\n  // Find the post by ID\n  const posts = getPosts();\n  const post = posts.find((p) => p.id === id);\n\n  if (!post) {\n    return NextResponse.json({ error: \"Post not found\" }, { status: 404 });\n  }\n\n  // Add tag only if it doesn’t already exist\n  if (!post.tags.includes(tag)) {\n    post.tags.push(tag);\n  }\n\n  // Return updated post\n  return NextResponse.json(post);\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/app/api/posts/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/app/api/tags/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/app/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/app/page.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Button' is defined but never used.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// File: app/page.tsx\n\"use client\";\n\nimport { useState } from \"react\";\nimport {\n  Box,\n  Container,\n  Flex,\n  Heading,\n  Text,\n  Input,\n  Button,\n} from \"@chakra-ui/react\";\nimport { FiltersBar } from \"@/components/FiltersBar\";\nimport { TagsFilterPopover } from \"@/components/TagsFilterPopover\";\nimport { PostsTable } from \"@/components/PostsTable\";\nimport { LoadMoreButton } from \"@/components/LoadMoreButton\";\nimport { usePosts } from \"@/hooks/usePosts\";\nimport { FiltersContext } from \"@/context/FiltersContext\";\nimport { PortalToast } from \"@/components/PortalToast\";\n\nconst POSTS_PER_PAGE = 10; // Number of posts to display per page\n\nexport default function Home() {\n  const [status, setStatus] = useState<string>(\"all\");\n  const [platform, setPlatform] = useState<string>(\"all\");\n  const [selectedTags, setSelectedTags] = useState<string[]>([]);\n  const [search, setSearch] = useState(\"\");\n\n  // Cursor-paginated data + controls\n  const {\n    posts,\n    loading, // initial page load\n    loadingMore, // subsequent pages\n    hasMore, // whether \"Load more\" should be enabled\n    error,\n    loadMore, // fetch next page\n    hasLoaded, // first load finished (success or error)\n  } = usePosts(platform, status, selectedTags, search, POSTS_PER_PAGE);\n\n  return (\n    <FiltersContext.Provider\n      value={{\n        status,\n        setStatus,\n        platform,\n        setPlatform,\n        selectedTags,\n        setSelectedTags,\n        search,\n        setSearch,\n      }}\n    >\n      <Flex justify=\"center\" bg=\"gray.50\" minH=\"100vh\" align=\"flex-start\">\n        <Container\n          maxW=\"container.lg\"\n          px={{ base: 4, md: 6 }}\n          py={{ base: 6, md: 8 }}\n          bgGradient=\"linear(to-r, blue.50, purple.50)\"\n          borderRadius=\"lg\"\n          boxShadow=\"md\"\n          mt={8}\n        >\n          <Heading size=\"2xl\" mb={6} color=\"purple.700\" textAlign=\"center\">\n            Flagged Posts Review\n          </Heading>\n\n          <FiltersBar />\n\n          <Box mt={4} mb={4} textAlign=\"center\">\n            <Input\n              placeholder=\"Search posts…\"\n              value={search}\n              onChange={(e) => setSearch(e.target.value)}\n              maxW=\"400px\"\n              p={3}\n            />\n          </Box>\n\n          <Box mt={2} mb={4} textAlign=\"center\">\n            <TagsFilterPopover />\n          </Box>\n\n          {/* Error state via toast */}\n          {error && (\n            <PortalToast\n              title=\"Error loading posts\"\n              description={error}\n              status=\"error\"\n              duration={2000}\n            />\n          )}\n\n          {/* Loading / empty / table */}\n          {!hasLoaded || loading ? (\n            <Box textAlign=\"center\" p={10}>\n              <Text color=\"gray.600\">Loading posts…</Text>\n            </Box>\n          ) : posts.length === 0 ? (\n            <Box\n              textAlign=\"center\"\n              p={10}\n              bg=\"white\"\n              borderRadius=\"md\"\n              boxShadow=\"sm\"\n            >\n              <Text fontSize=\"lg\" color=\"gray.600\">\n                No posts match the current filters.\n              </Text>\n            </Box>\n          ) : (\n            <>\n              <PostsTable posts={posts} />\n\n              {/* Load More control for cursor pagination */}\n              <LoadMoreButton\n                hasMore={hasMore}\n                loadingMore={loadingMore}\n                onClick={loadMore}\n              />\n            </>\n          )}\n        </Container>\n      </Flex>\n    </FiltersContext.Provider>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/app/providers.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/components/FiltersBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/components/LoadMoreButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/components/PortalToast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/components/PostRow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/components/PostsTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/components/TagsFilterPopover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/context/FiltersContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/hooks/useCursorPager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2110,2113],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2110,2113],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3502,3505],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3502,3505],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef, useState, useCallback } from \"react\";\n\n// Items must expose a stable 'id'\ntype HasId = { id: string | number };\n\n// Page result shape\nexport type PageResult<T> = { data: T[]; nextCursor: string | null };\n\n// Fetch function signature\nexport type FetchPage<T> = (\n  cursor: string | null,\n  limit: number\n) => Promise<PageResult<T>>;\n\n// Cursor-based pagination hook\nexport function useCursorPager<T extends HasId>(\n  fetchPage: FetchPage<T>, // async function to fetch a page of data\n  pageSize = 20 // default number of items per page\n) {\n  // Core state\n  const [items, setItems] = useState<T[]>([]);\n  const [nextCursor, setNextCursor] = useState<string | null>(null);\n  const [loading, setLoading] = useState(false); // first page load\n  const [loadingMore, setLoadingMore] = useState(false); // subsequent loads\n  const [error, setError] = useState<string | null>(null);\n  // Track whether the first page has finished (success or error) so consumers\n  // can suppress premature empty states while the initial load is in flight.\n  const [hasLoaded, setHasLoaded] = useState(false);\n\n  // Sequence to discard stale responses\n  const reqSeqRef = useRef(0);\n\n  // Mounted flag\n  const activeRef = useRef(true);\n  useEffect(\n    () => () => {\n      // On unmount, mark as inactive so we stop updating state\n      activeRef.current = false;\n    },\n    []\n  );\n\n  // First page fetch/reset\n  const fetchFirst = useCallback(async () => {\n    // Reset first-load completion flag so UI knows a new initial load started\n    setHasLoaded(false);\n    setLoading(true);\n    setLoadingMore(false);\n    setError(null);\n    setItems([]);\n    setNextCursor(null);\n\n    const seq = ++reqSeqRef.current; // bump sequence number\n    try {\n      // Request first page (no cursor)\n      const { data, nextCursor } = await fetchPage(null, pageSize);\n      // Ignore response if component unmounted or if a newer request started\n      if (!activeRef.current || seq !== reqSeqRef.current) return;\n      // Save results\n      setItems(data ?? []);\n      setNextCursor(nextCursor ?? null);\n    } catch (e: any) {\n      // Same guards: only handle error if still active + latest request\n      if (!activeRef.current || seq !== reqSeqRef.current) return;\n      setError(e?.message || \"Failed to fetch data\");\n      setItems([]);\n      setNextCursor(null);\n    } finally {\n      if (activeRef.current && seq === reqSeqRef.current) {\n        setLoading(false); // Turn off loading if still relevant\n        setHasLoaded(true); // Mark that the first attempt has completed (success or error) if still active\n      }\n    }\n  }, [fetchPage, pageSize]);\n\n  // Fetch subsequent page\n  const fetchNext = useCallback(async () => {\n    // Guard: don’t fetch if already loading or no more pages\n    if (loading || loadingMore || !nextCursor) return;\n    setLoadingMore(true);\n    setError(null);\n\n    const seq = ++reqSeqRef.current; // bump sequence number\n    try {\n      // Request next page using current cursor\n      const { data, nextCursor: nc } = await fetchPage(nextCursor, pageSize);\n      if (!activeRef.current || seq !== reqSeqRef.current) return;\n      setItems((prev) => {\n        // Build a set of seen ids\n        const seen = new Set(prev.map((x) => String(x.id)));\n        // Filter out duplicates before appending\n        const additions = (data ?? []).filter((x) => !seen.has(String(x.id)));\n        return prev.concat(additions);\n      });\n      setNextCursor(nc ?? null);\n    } catch (e: any) {\n      if (!activeRef.current || seq !== reqSeqRef.current) return;\n      setError(e?.message || \"Failed to fetch more data\");\n    } finally {\n      if (activeRef.current && seq === reqSeqRef.current) setLoadingMore(false);\n    }\n  }, [loading, loadingMore, nextCursor, fetchPage, pageSize]);\n\n  // Kick off initial load\n  useEffect(() => {\n    fetchFirst();\n  }, [fetchFirst]);\n\n  // Public API\n  return {\n    items, // accumulated list of items\n    loading, // true while first page is loading\n    loadingMore, // true while additional pages are loading\n    hasMore: nextCursor !== null, // whether more pages exist\n    error, // error message if last fetch failed\n    refresh: fetchFirst, // restart pagination from scratch\n    loadMore: fetchNext, // load the next page\n    hasLoaded, // whether the first page load cycle has completed\n  } as const;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/hooks/usePosts.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'limit' is defined but never used.","line":19,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":47},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a missing dependency: 'tags'. Either include it or remove the dependency array.","line":61,"column":6,"nodeType":"ArrayExpression","endLine":61,"endColumn":64,"suggestions":[{"desc":"Update the dependencies array to be: [platform, status, search, pageSize, tags]","fix":{"range":[1986,2044],"text":"[platform, status, search, pageSize, tags]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":61,"column":25,"nodeType":"CallExpression","endLine":61,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo } from \"react\";\nimport type { Post } from \"@/lib/posts\";\nimport { useCursorPager } from \"./useCursorPager\";\n\n/**\n * Custom React hook to fetch posts from the backend with cursor-based pagination\n * and filtering (platform, status, tags, search).\n */\nexport function usePosts(\n  platform: string,\n  status: string,\n  tags: string[],\n  search: string,\n  pageSize = 20\n) {\n  // Build a memoized function that fetches a single page of posts\n  // The function is re-created only if filters or page size change\n  const fetchPage = useMemo(() => {\n    return async (cursor: string | null, limit: number) => {\n      const params = new URLSearchParams();\n\n      // Add platform filter if not \"all\"\n      if (platform && platform !== \"all\") params.append(\"platform\", platform);\n\n      // Add status filter if not \"all\"\n      if (status && status !== \"all\") params.append(\"status\", status);\n\n      // Add tags filter(s) (each non-empty trimmed tag)\n      for (const t of tags || []) {\n        const v = t?.trim();\n        if (v) params.append(\"tag\", v);\n      }\n\n      // Add search filter if provided\n      const q = search?.trim();\n      if (q) params.append(\"search\", q);\n\n      // Ensure page size is within [1, 100]\n      params.set(\"limit\", String(Math.min(Math.max(pageSize || 20, 1), 100)));\n\n      // Add cursor param if provided (for pagination)\n      if (cursor) params.set(\"cursor\", cursor);\n\n      // Perform API request to fetch posts\n      const res = await fetch(`/api/posts?${params.toString()}`);\n\n      // Throw error if request failed\n      if (!res.ok) {\n        throw new Error(\n          `Failed to fetch posts: ${res.status} ${res.statusText}`\n        );\n      }\n\n      // Parse and return JSON response (posts and nextCursor)\n      const json: { data: Post[]; nextCursor: string | null } =\n        await res.json();\n      return json;\n    };\n    // Dependencies: changing any filter or pageSize regenerates the fetcher,\n    // which resets the pager\n  }, [platform, status, JSON.stringify(tags), search, pageSize]);\n\n  // Initialize cursor pager hook with the fetch function and page size\n  const pager = useCursorPager<Post>(fetchPage, pageSize);\n\n  // Expose pager state and actions in a structured return value\n  return {\n    posts: pager.items, // List of posts fetched so far\n    loading: pager.loading, // True while first page is loading\n    loadingMore: pager.loadingMore, // True while additional pages load\n    hasMore: pager.hasMore, // Indicates if more posts are available\n    error: pager.error, // Error message if request failed\n    loadMore: pager.loadMore, // Function to fetch next page\n    refresh: pager.refresh, // Function to reload data from start\n    hasLoaded: pager.hasLoaded, // First load finished (success or error)\n  } as const;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/hooks/useTags.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[923,926],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[923,926],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useState } from \"react\";\n\n/**\n * Custom React hook to fetch and return a list of tags from the backend.\n */\nexport function useTags() {\n  // State to hold the list of tags\n  const [tags, setTags] = useState<string[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    // \"active\" flag prevents setting state if the component unmounts\n    let active = true;\n\n    // Start loading before making the request\n    setLoading(true);\n\n    // Fetch tags from the API endpoint\n    fetch(\"/api/tags\")\n      .then(async (r) => {\n        if (!r.ok) {\n          throw new Error(`Failed to load tags: ${r.status}`);\n        }\n        return r.json();\n      })\n      .then((data: string[]) => {\n        if (active) {\n          setTags(Array.isArray(data) ? data : []);\n          setError(null);\n        }\n      })\n      .catch((e: any) => {\n        if (active) setError(e?.message || \"Failed to load tags\");\n      })\n      .finally(() => {\n        if (active) setLoading(false);\n      });\n\n    // Cleanup function sets active = false if component unmounts\n    return () => {\n      active = false;\n    };\n  }, []); // Empty dependency array → runs only on mount\n\n  // Expose tags and loading state\n  return { tags, loading, error } as const;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/lib/platforms.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/lib/posts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/helizakay/Desktop/flagged-posts-review/src/lib/statuses.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]